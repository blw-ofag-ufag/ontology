library(srppp)
library(DiagrammeR)
library(uwot)
library(mclust)
library(pheatmap)

# download current SRPPP register
current_register <- srppp_dm()
dm_draw(current_register)


for (i in colnames(current_register$categories)) {
  cat(sprintf("\n:%s a owl:DatatypeProperty ;\n\trdfs:domain :Category ;\n\trdfs:range xsd:string .", i))
}

current_register$products
unique(current_register$categories[,-1])
unique(current_register$formulation_codes[,-1])
unique(current_register$danger_symbols[,-1])
unique(current_register$CodeS[,-1])
unique(current_register$CodeR[,-1])
unique(current_register$CodeS[,-1])
unique(current_register$signal_words[,-1])
current_register$parallel_imports
current_register$substances
current_register$ingredients
current_register$uses
unique(current_register$application_comments[,-c(1,2)])
unique(current_register$culture_forms[,-c(1,2)])
unique(current_register$cultures[,-c(1,2)])
unique(current_register$pests[,-c(1,2)])
unique(current_register$obligations[,-c(1,2)])

# comments (in German)
S = current_register$CodeS$CodeS_de |> unique()
R = current_register$CodeR$CodeR_de |> unique()
current_register$application_comments$application_comment_de |> unique()
current_register$obligations$code |> unique()

# extract obligations
x = current_register$obligations$obligation_de |>
  table() |>
  sort(decreasing = T)
y = names(x)
obligations = data.frame(id = 1:length(y), obligation = y, count = as.integer(x))
write.csv(obligations, "obligations.csv", row.names = FALSE)

# current_register$products
# current_register$ingredients
# current_register$formulation_codes
# current_register$substances

# current_register$uses |> View()
# current_register$uses$units_de |> unique()
# current_register$cultures$culture_de |> unique()
# current_register$culture_forms



# Code S to RDF
# X = as.data.frame(unique(current_register$CodeS[,3:6]))
# for (i in 1:nrow(X)) {
#   cat(sprintf("\n:hazardLabelS%s a :hazardLabel ; \n\trdfs:label \"%s\"@de , \n\t\t\"%s\"@fr , \n\t\t\"%s\"@it", i, X[i,2], X[i,3], X[i,4]))
#   if(is.na(X[i,1]) | grepl("^\\s*$", X[i,1])) cat(".") else cat(sprintf(" ;\n\t:hasGHScode \"%s\" .", X[i,1]))
# }

# load embeddings generated by OpenAI
data = read.csv("embeddings-100.csv")
X = as.matrix(data[,-c(1:2)])
obligations = read.csv("obligations.csv")

# PCA
PCA = prcomp(X)
cumsum = 100*cumsum(PCA$sdev^2)/sum(PCA$sdev^2)
which(cumsum>80) |> min()
plot(100*cumsum(PCA$sdev^2)/sum(PCA$sdev^2), log = "x", type = "l", lwd = 4, xlab = "Number of components", ylab = "Variance explained [%]", las = 1)
abline(h = seq(0,100,10), v = c(1,5,10,50,100,500,1000), lty = 3)

# UMAP
UMAP = umap(X, n_neighbors = 300, n_components = 2, metric = "euclidean", verbose = TRUE)
plot(UMAP, pch = 16, col = "#00000022", cex = 1.5)

# hierarchical clustering
HC = hclust(dist(PCA$x))
plot(HC, labels = FALSE, hang = 0)
k = 20
table(cutree(HC, k = k)) # unfortunately, clustered elements are often not semantically related...
plot(UMAP, pch = 16, col = viridis::viridis(k)[cutree(HC, k = k)])
# heatmap(as.matrix(dist(X[,1:10])))

# Gaussian mixture modelling
GMM = Mclust(PCA$x[,1:40], G = 1:k, modelNames = c("VVE","VEI","VII","VVI","VVV"))
plot(GMM, what = "BIC")
plot(GMM, what = "uncertainty", dimens = 1:3, col = viridis::viridis(GMM$G))
plot(PCA$x[,1:2], pch = 16, col = viridis::viridis(GMM$G)[GMM$classification])
plot(UMAP, pch = 16, col = viridis::viridis(GMM$G)[GMM$classification])

# dbscan creates very imbalanced clusters
library(dbscan)
DBSCAN = dbscan(X, eps = .33)
plot(UMAP, pch = 16, col = viridis::viridis(length(unique(DBSCAN$cluster)))[DBSCAN$cluster+1])

# export results
rank <- function(x) {
  x |> table() |> sort() |> names() |> as.integer() -> y
  names(y) = LETTERS[1:length(y)]
  as.factor(names(sort(y))[x])
}
results = data.frame(
  PC1 = PCA$x[,1],
  PC2 = PCA$x[,2],
  UMAP1 = UMAP[,1],
  UMAP2 = UMAP[,2],
  HC = rank(cutree(HC, k = k)),
  GMM = rank(GMM$classification),
  DBSCAN = rank(DBSCAN$cluster+1),
  uncertainty = GMM$uncertainty,
  obligation = data$obligation,
  id = data$id,
  count = obligations[data$id,"count"])
write.csv(results[order(results$GMM, decreasing = F),], "results.csv", row.names = FALSE)
